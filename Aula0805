BUBBLE SORT
1.
A ideia do Bubble Sort √© comparar pares de elementos adjacentes e trocar suas posi√ß√µes se estiverem fora de ordem. A cada 
passagem pelo vetor, o maior valor vai "subindo" para o final, como uma bolha na √°gua ‚Äî da√≠ o nome bubble.

2.
Para isso, usamos dois la√ßos aninhados:

O primeiro la√ßo (i) representa o n√∫mero de passagens completas pelo vetor.
A cada nova passagem, o algoritmo garante que mais um elemento est√° na posi√ß√£o correta, no final do vetor.

O segundo la√ßo (j) percorre os elementos ainda desordenados e compara o valor atual com o pr√≥ximo (vetor[j] com vetor[j+1]).
Se estiverem na ordem errada (o da esquerda for maior que o da direita), o algoritmo troca os dois de posi√ß√£o.

3.
Depois de cada passagem do la√ßo interno, o maior valor restante j√° est√° posicionado corretamente no final do vetor.
Esse processo se repete at√© que o vetor inteiro esteja ordenado.

üí° Resumo visual do processo:

Primeira passagem ‚Üí o maior valor vai para o final.

Segunda passagem ‚Üí o segundo maior vai para a pen√∫ltima posi√ß√£o.

E assim por diante, at√© tudo estar ordenado.
        
        
    }
    
}

int[] vetor =  {7, 5, 10, 3, 4};
passos
Passo 1 - 5  7  3  4  10  
Passo 2 - 5  3  4  7  10  
Passo 3 - 3  4  5  7  10  
Passo 4 - 3  4  5  7  10  
Passo 5 - 3  4  5  7  10  

public class OrdenacaoBubbleSort {
    public static void main(String[] args) 
    {
        int[] vetor = {7, 5,10, 3, 4};
        int temp; // Vari√°vel auxiliar para troca de valores
        System.out.println("\nBubble Sort");
        
        System.out.println("\nVetor original");
        for(int i = 0; i < vetor.length; i++)
        {
            System.out.println(" Posicao[" + i + "] = " + vetor[i]);
                 
        }
        
        System.out.println("\n passos");
        // La√ßo externo: controla o n√∫mero de "passadas"
        for (int i = 0; i < vetor.length; i++) 
        {
             // La√ßo interno: compara pares de elementos adjacentes
            for(int j = 0; j < vetor.length - 1; j++)
            {
                // Se o valor atual for maior que o pr√≥ximo, troca
                if (vetor[j] > vetor[j+1])
                {
                    //Troca os elementos de lugar
                    temp = vetor[j];
                    vetor[j] = vetor[j+1];
                    vetor[j + 1] = temp;
           
                }
                                    
            }
            // Exibe o vetor ap√≥s cada passo completo
            System.out.print("Passo " + (i + 1) + " - ");
            for(int j = 0; j < vetor.length; j++)
            {
                System.out.print(vetor[j] + "  ");
            }
            System.out.println("");
        }
        
        
        System.out.println("\n Vetor ordenado");
        for(int i = 0; i < vetor.length; i++)
        {
            System.out.println(" Posicao[" + i + "] = " + vetor[i]);
        }
    
    } 
    
}

SELECTION SORT

Explica√ß√£o passo a passo (em portugu√™s simples):
1.	A ideia do Selection Sort √© encontrar o menor elemento do vetor e coloc√°-lo na primeira posi√ß√£o, depois encontrar o segundo
menor e coloc√°-lo na segunda posi√ß√£o, e assim por diante.

2.	Para isso, percorremos o vetor com dois la√ßos:
o	O primeiro la√ßo (i) controla a posi√ß√£o atual onde vamos colocar o menor valor.
o	O segundo la√ßo (j) procura o menor valor entre os elementos restantes.
3.	Depois de encontrar o menor valor, trocamos com o valor da posi√ß√£o i.
________________________________________

1.	O for (int i = 1; i < vetor.length - 1; i++) deveria come√ßar de i = 0, n√£o de i = 1, pois o Selection Sort come√ßa do 
primeiro elemento.
2.	O loop de exibi√ß√£o dos passos imprime apenas parte do vetor, n√£o o vetor inteiro, o que pode gerar confus√£o.
3.	O trecho menor = vetor[indice]; depois do for interno √© redundante ‚Äî j√° foi feito dentro do if.
4.	Coment√°rios e identa√ß√£o podem ser melhor organizados.
________________________________________
int[] vetor =  {7, 5, 10, 3, 4};
passos da ordena√ß√£o
Passo 1 - 3  5  10  7  4   
Passo 2 - 3  4  10  7  5   
Passo 3 - 3  4  5  7  10   
Passo 4 - 3  4  5  7  10   


public class OrdenacaoSelectionSort {
    public static void main(String[] args) 
    {
        int[] vetor = {7, 5,10, 3, 4};
        System.out.println(" Selection Sort\n");
        
        System.out.println(" Vetor original");
        for(int i = 0; i < vetor.length; i++)
        {
            
            System.out.println(" Posicao[" + i + "] = " + vetor[i]);
                 
        }
        
        System.out.println("\npassos da ordena√ß√£o");
        // La√ßo externo percorre o vetor at√© a pen√∫ltima posi√ß√£o
        for (int i = 0; i < vetor.length - 1; i++) 
        {
            // Assume que o menor valor est√° na posi√ß√£o atual
            int menor = vetor[i];
            int indice = i;

            // La√ßo interno procura o menor elemento √† frente da posi√ß√£o i
            for(int j = i + 1; j < vetor.length; j++)
            {
                if (vetor[j] < menor)
                {
                   // Atualiza o menor valor e sua posi√ß√£o
                    menor = vetor[j];
                    indice = j;
                               
                }
                                    
            }
            // Troca o menor valor encontrado com o valor da posi√ß√£o atual (i)
            menor = vetor[indice]; // redundante, pois menor j√° tem esse valor
            vetor[indice] = vetor[i]; // move o valor atual para a posi√ß√£o do menor
            vetor[i] = menor; // coloca o menor na posi√ß√£o atual
            
            
            // Exibe o vetor ap√≥s cada passo da ordena√ß√£o
            System.out.print("Passo " + (i + 1) + " - ");
            for(int j = 0; j < vetor.length; j++)
            {
                System.out.print(vetor[j] + "  ");
            }
            System.out.println(" ");
        }
        
      
        System.out.println("\n Vetor ordenado");
        for(int i = 0; i < vetor.length; i++)
        {
            System.out.println(" Posicao[" + i + "] = " + vetor[i]);
        }     
    }   
}

INSERT SORT

1.
A ideia do Insertion Sort √© percorrer o vetor e, a cada elemento, inseri-lo na posi√ß√£o correta entre os elementos j√° ordenados √† esquerda.
Ou seja, o algoritmo vai construindo uma parte ordenada do vetor √† medida que avan√ßa.

2.
Para isso, usamos dois controles:

O primeiro la√ßo (i) percorre o vetor a partir do segundo elemento (√≠ndice 1), pois o primeiro elemento sozinho j√° √© considerado 
ordenado.

Uma vari√°vel auxiliar (j) percorre a parte ordenada (√† esquerda de i) de tr√°s para frente, comparando os elementos com o valor 
atual (o "eleito").

Se os elementos da parte ordenada forem maiores que o eleito, eles s√£o deslocados uma posi√ß√£o para a direita, abrindo espa√ßo 
para o eleito.

3.
Quando encontramos a posi√ß√£o correta, inserimos o valor eleito, completando a ordena√ß√£o daquela parte do vetor.
Esse processo se repete at√© o vetor inteiro estar ordenado.

üí° Resumo visual do processo:

Pega um elemento da parte n√£o ordenada.

Compara com os anteriores.

Move os maiores para frente.

Insere o elemento no local certo.

int[] vetor =  {7, 5, 10, 3, 4};
Passos da ordena√ß√£o
Passo 1 - 
5 7 10 3 4  
Passo 2 - 
5 7 10 3 4  
Passo 3 - 
3 5 7 10 4  
Passo 4 - 
3 4 5 7 10  

public class OrdenacaoInsertSort { 
public static void main(String[] args) 
    {
        int[] vetor =  {7, 5, 10, 3, 4};
        System.out.println(" Insert Sort\n");
        
        
        System.out.println("\nVetor Original");
        for(int i = 0; i < vetor.length; i++)
        {
            System.out.println(" Posi√ß√£o[" + i + "] = " + vetor[i]);
        }

        // In√≠cio do algoritmo Insertion Sort
        System.out.println("\nPassos da ordena√ß√£o");

        // Come√ßa da posi√ß√£o 1 (o primeiro elemento j√° est√° "ordenado")
        for(int i = 1; i < vetor.length; i++)
        {
            int eleito = vetor[i]; // Elemento que ser√° inserido na posi√ß√£o correta
            int j = i - 1;

             // Move os elementos maiores que o "eleito" para a direita
            while (j >= 0 && vetor[j] > eleito)
            {
                vetor[j + 1] = vetor[j];
                j = j - 1;
            }
            // Insere o "eleito" na posi√ß√£o correta
            vetor[j + 1] = eleito; 
        
            System.out.println("Passo " + i + " - ");
            for(j = 0; j < vetor.length; j++)
            {
                System.out.print(vetor[j] + " ");
            }
            System.out.println(" ");
            
        }
        System.out.println("\n Vetor ordenado");
        for(int i = 0; i < vetor.length; i++)
        {
            System.out.println(" Posi√ß√£o[" + i + "] = " + vetor[i]);
        }    
    }   
}
